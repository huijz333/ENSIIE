\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{floatrow}

\usepackage{algorithm, algpseudocode}
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{scrextend}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage[hmargin=1.25in,vmargin=1.25in]{geometry}

%title setup
\title{Projet IPF: SUBSET-SUM-OPT}
\author{Romain PEREIRA}
\date{03/04/2018}

% table of contents setup
\renewcommand{\contentsname}{Sommaire}
\usepackage{etoolbox}
\patchcmd{\thebibliography}{\section*{\refname}}{}{}{}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=red
}
			
\begin{document}
	\maketitle
	\tableofcontents

	\section*{Préambule}

		Ce projet est réalisé dans le cadre de mes études à l'ENSIIE. Rappel de l'énoncé:
		
		\begin{addmargin}[2em]{0em}
			SUBSET-SUM-OPT - Etant donnée un ensemble fini $E$ d'entiers
			strictements positifs et un entier cible s, trouver l'entier
			$s' \leq s$ le plus grand possible, tel qu'il existe un
			sous-ensemble $E' \subseteq E$ vérifiant $\sum_{e \in E'}{e} = s'$.
			\newline
		\end{addmargin}
		Ce rapport présente (en pseudo-code), les algorithmes implémentés.
		Le code OCaml est disponible dans le rendu, dans des fichiers de types 'approche\_naive.ml', 'approche\_plus\_directe.ml' ...
		\newline
		\newline
		Un Makefile est disponible pour compiler le projet et les tests:
		\begin{itemize}[label=-]
			\setlength\itemsep{0.1em}
			\item \textit{make} : compile les fichiers sources avec les tests vers un executable \textbf{subset-sum-opt.out}
			\item \textit{clean} : supprimes les fichiers compilés temporaires (.mlo et .cmo)
			\item \textit{fclean} : supprimes tous les fichiers compilés (executable et temporaires)
		\end{itemize}
	
	\newpage
	\section{Approche naïve}\label{approche_naive}
		Cette approche consiste à determiner tous les sous-ensembles $E'$ de $E$, d'effectuer la somme sur
		tous les $E'$, et de renvoyer la somme la plus proche de $s$. Cette approche par 'force brute' est lourde.
		\newline
		\newline
		Si $Card(E) = n$, alors $Card(P(E)) = 2^n$, et $\forall E' \in P(E) , 0 <= Card(E') <= n$
		\newline
		Résoudre le problème (génerer ces ensembles et sommer dessus) se fait donc en $\boxed{O(2^nn)}$
		\subsection{Question 1 : somme sur un ensemble}
			\begin{algorithm}
				\caption{Renvoie la somme des éléments de E}
				\begin{algorithmic}[1]
					\Function{Somme}{$E' \subset \mathbb{N}$}
						\If{$E' = \emptyset$}
							\Return 0
						\EndIf
						\State Soit $x \in E'$
						\Return x + $\mathtt{Somme}(E' \backslash \{x\}$)
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $\boxed{O(n)}$, où $n = Card(E')$
			
		\subsection{Question 2 : génération des parties d'un ensemble}
			\begin{algorithm}
				\caption{Renvoie l'ensemble des parties de E}
				\begin{algorithmic}[1]
					\Function{Sous-ensembles}{$E \subset \mathbb{N}$}
						\If{$E = \emptyset$}
							\Return $\{\emptyset\}$
						\EndIf
						\State Soit $x \in E$
						\State Soit $P \leftarrow \mathtt{Sous-ensembles}(E \backslash \{x\})$
						\Return $P \cup \{E' \cup x \mid E' \in P\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $\boxed{O(2^n)}$, où $n = Card(E)$
		
		\subsection{Question 3 : résolution de SUBSET\_SUM\_OPT par force brute}
			\begin{algorithm}
				\caption{Renvoie la réponse au problème SUBSET\_SUM\_OPT sur (E, s)}
				\begin{algorithmic}[1]
					\Function{subset\_sum}{$E \subset \mathbb{N}, s \in \mathbb{N}$}
						\State Soit $P \leftarrow \mathtt{Sous-ensembles}(E)$
						\Return $\underset{E' \in P}{\max}\{s' \mid s' = \mathtt{Somme}(E') \quad et \quad s' \leq s\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $\boxed{O(2^nn)}$, où $n = Card(E)$
		\newpage
		\section{Approche plus directe}\label{approche_plus_directe}
			Dans cette approche, plutot que de calculer l'ensemble des parties de $E$,
			on se propose de calculer l'ensemble des sommes atteignables en sommet sur les parties de $E$.
			
			\subsection{Question 4 : sommes atteignables}
				\begin{algorithm}
					\caption{Renvoie l'ensemble des entiers $s$ tels qu'il existe $E' \subseteq E$ vérifiant $\sum\limits_{e \in E'}e = s$}
					\begin{algorithmic}[1]
						\Function{Get\_all\_sums}{$E \subset \mathbb{N}$}
							\If{$E = \emptyset$}
								\Return $\{0\}$
							\EndIf
							\State Soit $x \in E$
							\State $S \leftarrow \mathtt{Get\_all\_sums}(E \backslash \{x\})$
							\Return $S \cup \{x + s \mid s \in S\}$
						\EndFunction
					\end{algorithmic}
				\end{algorithm}
				Si l'on suppose:
				\begin{itemize}[label=-]
					\setlength\itemsep{0.1em}
					\item $n = Card(E)$
					\item $m(n) = Card\{sommes \quad atteignables\} = \{s \mid \exists E' \subseteq E \mid \sum\limits_{e \in E'}e = s\} \leq 2^n$
					\item $X \cup Y$ : opération en $O(Card(X) * Card(Y))$
				\end{itemize}
				Alors la complexité de cet algorithme est en $\boxed{O(m(n)^2 * n)}$
				\begin{itemize}[label=-]
					\setlength\itemsep{0.1em}
					\item $n$ : nombre de récursion
					\item $m(n)^2$ : l'union
				\end{itemize}

			\subsection{Question 5 : résolution de SUBSET\_SUM\_OPT}
				\begin{algorithm}
					\caption{Renvoie la réponse au problème SUBSET\_SUM\_OPT sur (E, s)}
					\begin{algorithmic}[1]
						\Function{subset\_sum}{$E \subset \mathbb{N}, s \in \mathbb{N}$}
							\State Soit $S \leftarrow \mathtt{Get\_all\_sums}(E)$
							\Return $\max\{s' \in S \mid 0 \leq s' \leq s\}$
						\EndFunction
					\end{algorithmic}
				\end{algorithm}
				La complexité de cet algorithme de résolution est donc en $\boxed{O(m(n)^3 * n)}$

	\newpage
		\section{Approche avec nettoyage}\label{approche_naive}
			On peut réduire la complexité de l'approche précèdente en réduisant ce que l'on a noté $m(n)$ (le nombre de sommes atteignables.
			Dans cette approche, on se propose d'ajouter un 'filtre' sur l'algorithme qui génère les sommes.
				\subsection{Question 6 ; fonction clean\_up}
					Le filtre (l'algorithme 'clean\_up') est donnée dans l'énoncé. Cette fonction prends en paramètre:
					\begin{itemize}[label=-]
						\setlength\itemsep{0.1em}
						\item $E \subset \mathbb{N}$ : l'ensemble a filtré
						\item $s \in \mathbb{N}$ : un entier positif
						\item $\delta \in \mathbb{R}_+^*$ : un réel positif (généralement $\ll 1$)
					\end{itemize}
					Cette fonction renvoie un nouvel ensemble $E' \subset E$, tel que:
					\begin{itemize}[label=-]
						\setlength\itemsep{0.1em}
						\item	$\forall x \in E' , x \leq s$
						\item	Si l'on considère la suite croissante $(u_n)_{n \in \mathbb{N}}$ des éléments de $E'$,
								$\forall n \in \mathbb{N}, u_{n + 1} \geq (1 + \delta)u_n $.
					\end{itemize}
		
					Autrement dit, tous les entiers strictement supérieurs à $n$ sont supprimés, et 
					si l'on considère 2 entiers consécutifs de l'ensemble trié $x$ et $y$, tel que $x < y$,
					ils sont 'proches d'un rapport d'au moins $(1 + \delta)$, $y$ est supprimé.
					Ce filtre supprime donc les éléments de l'ensemble qui sont 'proches' l'un de l'autre (au regard de $\delta$)

				\subsection{Question 7 : résolution de SUBSET\_SUM\_OPT}
					L'algorithme de résolution est également fourni dans l'énoncé.
					Il est le même que celui de 'l'approche plus directe' \ref{approche_plus_directe}, sauf que
					lors du calcul des sommes atteignables filtrés par la fonction 'clean\_up'.
					
					\begin{algorithm}
					\caption{Renvoie l'ensemble des entiers $s$ tels qu'il existe
								$E' \subseteq E$ vérifiant $\sum\limits_{e \in E'}e = s$, passant les tests du filtre}
					\begin{algorithmic}[1]
						\Function{Get\_all\_sums\_2}{$E \subset \mathbb{N}$}
							\If{$E = \emptyset$}
								\Return $\{0\}$
							\EndIf
							\State Soit $x \in E$
							\State $S \leftarrow \mathtt{Get\_all\_sums\_2}(E \backslash \{x\})$
							\Return $\mathtt{clean\_up}(S \cup \{x + s \mid s \in S\})$
						\EndFunction
					\end{algorithmic}
				\end{algorithm}
				
				\begin{algorithm}
					\caption{Renvoie la réponse au problème SUBSET\_SUM\_OPT sur (E, s)}
					\begin{algorithmic}[1]
						\Function{subset\_sum}{$E \subset \mathbb{N}, s \in \mathbb{N}$}
							\State Soit $S \leftarrow \mathtt{Get\_all\_sums\_2}(E)$
							\Return $\max\{s' \in S \mid 0 \leq s' \leq s\}$
						\EndFunction
					\end{algorithmic}
				\end{algorithm}
				La complexité de cet algorithme de résolution est donc en $\boxed{O(m'(n)^3 * n)}$
				
	\newpage
	\section{Références}
		\begin{thebibliography}{}
		
			\bibitem{cache_friendly}
				'Writting Cache-Friendly code', Gerson Robboy, Portland State University\newline
				\href{http://web.cecs.pdx.edu/~jrb/cs201/lectures/cache.friendly.code.pdf}
				      {\textit{http://web.cecs.pdx.edu/~jrb/cs201/lectures/cache.friendly.code.pdf}}.
  \end{thebibliography}

\end{document}
