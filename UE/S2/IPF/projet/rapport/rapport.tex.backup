\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{floatrow}

\usepackage{algorithm, algpseudocode}
\newcommand{\vars}{\texttt}
\newcommand{\func}{\textrm}
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{scrextend}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage[hmargin=1.25in,vmargin=1.25in]{geometry}

%title setup
\title{Projet IPF: SUBSET-SUM-OPT}
\author{Romain PEREIRA}
\date{03/04/2018}

% table of contents setup
\renewcommand{\contentsname}{Sommaire}
\usepackage{etoolbox}
\patchcmd{\thebibliography}{\section*{\refname}}{}{}{}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=red
}
			
\begin{document}
	\maketitle
	\tableofcontents

	\section*{Préambule}

		Ce projet est réalisé dans le cadre de mes études à l'ENSIIE. Rappel de l'énoncé:
		
		\begin{addmargin}[2em]{0em}
			SUBSET-SUM-OPT - Etant donnée un ensemble fini $E$ d'entiers
			strictements positifs et un entier cible s, trouver l'entier
			$s' \leq s$ le plus grand possible, tel qu'il existe un
			sous-ensemble $E' \subseteq E$ vérifiant $\sum_{e \in E'}{e} = s'$.
			\newline
		\end{addmargin}
		Le code est disponible dans le rendu.
		\newline
		Un Makefile est disponible pour compiler le projet et les tests:
		\begin{itemize}[label=-]
			\setlength\itemsep{0.1em}
			\item \textit{make} : compile les fichiers sources avec les tests vers un executable \textbf{subset-sum-opt.out}
			\item \textit{clean} : supprimes les fichiers compilés temporaires (.mlo et .cmo)
			\item \textit{fclean} : supprimes tous les fichiers compilés (executable et temporaires)
		\end{itemize}
	
	\newpage
	\section{Approche naïve}\label{approche_naive}
		Cette approche consiste à determiner tous les sous-ensembles $E'$ de $E$, d'effectuer la somme sur
		tous les $E'$, et de renvoyer la somme la plus proche de $s$. Cette approche par 'force brute' est lourde.
		\newline
		\newline
		Si $Card(E) = n$, alors $Card(P(E)) = 2^n$, et $\forall E' \in P(E) , 0 <= Card(E') <= n$
		\newline
		\newline
		Résoudre le problème (génerer ces ensembles et sommer dessus) se fait donc en $\boxed{O(2^nn)}$
		\newline
		\newline
		Le code est disponible dans le fichier \textbf{approche\_naive.ml}.
		\newline
		\subsection{Question 1 : somme sur un ensemble}
			\begin{algorithm}
				\caption{Renvoie la somme des éléments de E}
				\begin{algorithmic}[1]
					\Function{Somme}{$\vars{E'}$}
						\If{$E' = \emptyset$}
							\Return 0
						\EndIf
						\State Soit $x \in E'$
						\Return x + Somme($E' \backslash \{x\}$)
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $O(n)$, où $n = Card(E')$
			
		\subsection{Question 2 : génération des parties d'un ensemble}
			\begin{algorithm}
				\caption{Renvoie l'ensemble des parties de E}
				\begin{algorithmic}[1]
					\Function{Sous-ensembles}{$\vars{E}$}
						\If{$E = \emptyset$}
							\Return $\{\emptyset\}$
						\EndIf
						\State Soit $x \in E$
						\State Soit $P \leftarrow Sous-ensembles(E \backslash \{x\})$
						\Return $\{P\} \cup \{E' \cup x \mid E' \in P\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $O(2^n)$, où $n = Card(E)$
		
		\newpage
		\subsection{Question 3 : résolution de SUBSET\_SUM\_OPT par force brute}
			\begin{algorithm}
				\caption{Renvoie la réponse au problème SUBSET\_SUM\_OPT sur (E, s)}
				\begin{algorithmic}[1]
					\Function{subset\_sum}{$\vars{E}, \vars{s}$}
						\State Soit $P \leftarrow Sous-ensembles(E)$
						\Return $\underset{E' \in P}{\max}\{s' \mid s' = Somme(E') \quad et \quad s' \leq s\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $O(2^nn)$, où $n = Card(E)$
			
		\section{Approche plus directe}
			Dans cette approche, plutot que de calculer l'ensemble des parties de $E$,
			on se propose de calculer l'ensemble des sommes atteignables en sommet sur les parties de $E$.
			
			\subsection{Question 4 : sommes atteignables}
			\begin{algorithm}
				\caption{Renvoie l'ensemble des entiers $s$ tels qu'il existe $E' \subseteq E$ vérifiant $\sum\limits_{e \in E'}e = s$}
				\begin{algorithmic}[1]
					\Function{Get\_all\_sums}{$\vars{E}$}
						\If{$E = \emptyset$}
							\Return $\{0\}$
						\EndIf
						\State Soit $x \in E$
						\State $S \leftarrow Get\_all\_sums(E \backslash \{x\})$
						\Return $S \cup \{x + s \mid s \in S\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Si l'on suppose:
			\begin{itemize}[label=-]
				\setlength\itemsep{0.1em}
				\item $n = Card(E)$
				\item $m(n) = Card\{sommes \quad atteignables\} = \{s \mid \exists E' \subseteq E \mid \sum\limits_{e \in E'}e = s\} \leq 2^n$
				\item $X \cup Y$ : opération en $O(Card(X) * Card(Y))$
			\end{itemize}
			Alors la complexité de cet algorithme est en $O(m(n)^2 * n)$
			\newline
			\textbf{N.B:} $m(n) \leq 2^n$ est la seule information que l'on peut avoir... On ne peut donc pas
			comparer cette approche avec l'approche naïve \ref{approche_naive}

	\newpage
	\section{Références}
		\begin{thebibliography}{}
		
			\bibitem{cache_friendly}
				'Writting Cache-Friendly code', Gerson Robboy, Portland State University\newline
				\href{http://web.cecs.pdx.edu/~jrb/cs201/lectures/cache.friendly.code.pdf}
				      {\textit{http://web.cecs.pdx.edu/~jrb/cs201/lectures/cache.friendly.code.pdf}}.
  \end{thebibliography}

\end{document}
