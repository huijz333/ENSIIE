\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{floatrow}

\usepackage{algorithm, algpseudocode}
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{scrextend}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage[hmargin=1.25in,vmargin=1.25in]{geometry}

%title setup
\title{Projet IPF: SUBSET-SUM-OPT}
\author{Romain PEREIRA}
\date{03/04/2018}

% table of contents setup
\renewcommand{\contentsname}{Sommaire}
\usepackage{etoolbox}
\patchcmd{\thebibliography}{\section*{\refname}}{}{}{}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=red
}
			
\begin{document}
	\maketitle
	\tableofcontents

	\newpage
	\section{Préambule}

		Ce projet est réalisé dans le cadre de mes études à l'ENSIIE. Rappel de l'énoncé:
		
		\begin{addmargin}[2em]{0em}
			SUBSET-SUM-OPT - Etant donnée un ensemble fini $E$ d'entiers
			strictements positifs et un entier cible s, trouver l'entier
			$s' \leq s$ le plus grand possible, tel qu'il existe un
			sous-ensemble $E' \subseteq E$ vérifiant $\sum_{e \in E'}{e} = s'$.
			\newline
		\end{addmargin}
		Ce rapport présente (en pseudo-code), les algorithmes implémentés.
		\newline
		Le code OCaml est disponible dans le rendu.
		\newline
		Un Makefile est disponible pour compiler le projet et les tests:
		\begin{itemize}[label=-]
			\setlength\itemsep{0.1em}
			\item \textit{make} : compile les fichiers sources avec les tests vers un executable \textbf{subset-sum-opt.out}
			\item \textit{clean} : supprimes les fichiers compilés temporaires (.mlo et .cmo)
			\item \textit{fclean} : supprimes tous les fichiers compilés (executable et temporaires)
		\end{itemize}
		Les testes sont unitaires et effectue dans l'ordre:
		\begin{itemize}[label=-]
			\item Les fonctions du module \textit{Listes}
			\item Les fonctions du module \textit{Ensembles}
			\item Les fonctions du module \textit{Approche\_naïve}
			\item Les fonctions du module \textit{Approche\_plus\_directe}
			\item Les fonctions du module \textit{Approche\_avec\_nettoyage}
			\item Les fonctions du module \textit{Approche\_diviser\_pour\_regner}
			\item Les fonctions du module \textit{Approche\_diviser\_pour\_regner}
			\item Comparaisons des approches
		\end{itemize}

	\newpage
	\section{Spécificités techniques}\label{approche_naive}
		\subsection{Notations}
			J'utiliserai les notations suivantes:
			\begin{itemize}[label=-]
				\setlength\itemsep{0.1em}
				\item Soit $E$ est un ensemble, $Card(E)$ est le cardinal de $E$.
				\item Soit $E$ est un ensemble, $P(E)$ est l'ensemble formé des parties de $E$
			\end{itemize}
		\subsection{Rappels/Complexités}
			Soit $E$ un ensemble tel que $Card(E) = n$, alors
			$$Card(P(E)) = 2^n$$
			$$\forall E' \in P(E) , 0 <= Card(E') <= n$$
			\newline
			\newline
			On considèrera les complexités pour les opérations suivantes:
			\begin{itemize}[label=-]
				\setlength\itemsep{0.1em}
				\item Soit $(x, y)$ des scalaires, je considère que les 4 opérations élémentaires ($x+y$, $x-y$, $x*y$, $x/y$) sont en $O(1)$
				\item Soit 2 ensembles X, Y, $X \cup Y$ est une opération en $O(Card(X) * Card(Y))$
				\item Soit $E \subset \mathbb{N}$, $\max{E}$ est une opération en $O(Card(E))$
			\end{itemize}

	\newpage
	\section{Approche naïve}\label{approche_naive}
		Cette approche consiste à determiner tous les sous-ensembles $E'$ de $E$, d'effectuer la somme sur
		tous les $E'$, et de renvoyer la somme la plus proche de $s$. Cette approche par 'force brute' est lourde.
		\newline
		\newline
		\subsection{Question 1 : somme sur un ensemble}
			\begin{algorithm}
				\caption{Renvoie la somme des éléments de E}
				\begin{algorithmic}[1]
					\Function{Somme}{$E' \subset \mathbb{N}$}
						\If{$E' = \emptyset$}
							\Return 0
						\EndIf
						\State Soit $x \in E'$
						\Return x + $\mathtt{Somme}(E' \backslash \{x\}$)
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $\boxed{O(n)}$, où $n = Card(E')$
			
		\subsection{Question 2 : génération des parties d'un ensemble}
			\begin{algorithm}
				\caption{Renvoie l'ensemble des parties de E}
				\begin{algorithmic}[1]
					\Function{Sous-ensembles}{$E \subset \mathbb{N}$}
						\If{$E = \emptyset$}
							\Return $\{\emptyset\}$
						\EndIf
						\State Soit $x \in E$
						\State Soit $P \leftarrow \mathtt{Sous-ensembles}(E \backslash \{x\})$
						\Return $P \cup \{E' \cup x \mid E' \in P\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $\boxed{O(2^n)}$, où $n = Card(E)$
		
		\subsection{Question 3 : résolution de SUBSET\_SUM\_OPT par force brute}
			\begin{algorithm}
				\caption{Renvoie la réponse au problème SUBSET\_SUM\_OPT sur (E, s)}
				\begin{algorithmic}[1]
					\Function{subset\_sum}{$E \subset \mathbb{N}, s \in \mathbb{N}$}
						\State Soit $P \leftarrow \mathtt{Sous-ensembles}(E)$
						\Return $\underset{E' \in P}{\max}\{s' \mid s' = \mathtt{Somme}(E') \quad et \quad s' \leq s\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Complexité en $\boxed{O(2^{n+1}n)}$, où $n = Card(E)$
			
	\newpage
	\section{Approche plus directe}\label{approche_plus_directe}
		Dans cette approche, plutot que de calculer l'ensemble des parties de $E$,
		on se propose de calculer l'ensemble des sommes atteignables en sommet sur les parties de $E$.
		
		\subsection{Question 4 : sommes atteignables}
			\begin{algorithm}
				\caption{Renvoie l'ensemble des entiers $s$ tels qu'il existe $E' \subseteq E$ vérifiant $\sum\limits_{e \in E'}e = s$}
				\begin{algorithmic}[1]
					\Function{Get\_all\_sums}{$E \subset \mathbb{N}$}
						\If{$E = \emptyset$}
							\Return $\{0\}$
						\EndIf
						\State Soit $x \in E$
						\State $S \leftarrow \mathtt{Get\_all\_sums}(E \backslash \{x\})$
						\Return $S \cup \{x + s \mid s \in S\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			Si l'on suppose:
			\begin{itemize}[label=-]
				\setlength\itemsep{0.1em}
				\item $n = Card(E)$
				\item $m(n) = Card\{sommes \quad atteignables\} = \{s \mid \exists E' \subseteq E \mid \sum\limits_{e \in E'}e = s\} \leq 2^n$
			\end{itemize}
			Alors la complexité de cet algorithme est en $\boxed{O(m(n)^2 * n)}$
			\begin{itemize}[label=-]
				\setlength\itemsep{0.1em}
				\item $n$ : nombre de récursion
				\item $m(n)^2$ : l'union
			\end{itemize}

		\subsection{Question 5 : résolution de SUBSET\_SUM\_OPT}
			\begin{algorithm}
				\caption{Renvoie la réponse au problème SUBSET\_SUM\_OPT sur (E, s)}
				\begin{algorithmic}[1]
					\Function{subset\_sum}{$E \subset \mathbb{N}, s \in \mathbb{N}$}
						\State Soit $S \leftarrow \mathtt{Get\_all\_sums}(E)$
						\Return $\max\{s' \in S \mid 0 \leq s' \leq s\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			La complexité de cet algorithme de résolution est donc en $\boxed{O(m(n)^2 * n)}$

	\newpage
	\section{Approche avec nettoyage}\label{approche_naive}
		On peut réduire la complexité de l'approche précèdente en réduisant ce que l'on a noté $m(n)$ (le nombre de sommes atteignables.
		Dans cette approche, on se propose d'ajouter un 'filtre' sur l'algorithme qui génère les sommes.
			\subsection{Question 6 ; fonction clean\_up}
				Le filtre (l'algorithme 'clean\_up') est donnée dans l'énoncé. Cette fonction prends en paramètre:
				\begin{itemize}[label=-]
					\setlength\itemsep{0.1em}
					\item $E \subset \mathbb{N}$ : l'ensemble a filtré
					\item $s \in \mathbb{N}$ : un entier positif
					\item $\delta \in \mathbb{R}_+^*$ : un réel positif (généralement $\ll 1$)
				\end{itemize}
				Cette fonction renvoie un nouvel ensemble $E' \subset E$, tel que:
				\begin{itemize}[label=-]
					\setlength\itemsep{0.1em}
					\item	$\forall x \in E' , x \leq s$
					\item	Si l'on considère la suite croissante $(u_n)_{n \in \mathbb{N}}$ des éléments de $E'$,
							$\forall n \in \mathbb{N}, u_{n + 1} \geq (1 + \delta)u_n $.
				\end{itemize}
	
				Autrement dit, tous les entiers strictement supérieurs à $s$ sont supprimés, et 
				si l'on considère 2 entiers consécutifs de l'ensemble trié $x$ et $y$, tel que $x < y$,
				ils sont 'proches d'un rapport d'au moins $(1 + \delta)$, $y$ est supprimé.
				Ce filtre supprime donc les éléments de l'ensemble qui sont 'proches' l'un de l'autre (au regard de $\delta$)

			\subsection{Question 7 : résolution de SUBSET\_SUM\_OPT}
				L'algorithme de résolution est également fourni dans l'énoncé.
				Il est le même que celui de 'l'approche plus directe' \ref{approche_plus_directe}, sauf que
				lors du calcul des sommes atteignables filtrés par la fonction 'clean\_up'.
				
				\begin{algorithm}
					\caption{Renvoie l'ensemble des entiers $s$ tels qu'il existe
							$E' \subseteq E$ vérifiant $\sum\limits_{e \in E'}e = s$, passant les tests du filtre}
					\begin{algorithmic}[1]
						\Function{Get\_all\_sums\_2}{$E \subset \mathbb{N}$}
							\If{$E = \emptyset$}
								\Return $\{0\}$
							\EndIf
							\State Soit $x \in E$
							\State $S \leftarrow \mathtt{Get\_all\_sums\_2}(E \backslash \{x\})$
							\Return $\mathtt{clean\_up}(S \cup \{x + s \mid s \in S\})$
						\EndFunction
					\end{algorithmic}
				\end{algorithm}
			
			\begin{algorithm}
				\caption{Renvoie la réponse au problème SUBSET\_SUM\_OPT sur (E, s)}
				\begin{algorithmic}[1]
					\Function{subset\_sum}{$E \subset \mathbb{N}, s \in \mathbb{N}$}
						\State Soit $S \leftarrow \mathtt{Get\_all\_sums\_2}(E)$
						\Return $\max\{s' \in S \mid 0 \leq s' \leq s\}$
					\EndFunction
				\end{algorithmic}
			\end{algorithm}
			La complexité de cet algorithme de résolution est donc en $\boxed{O(m'(n)^2 * n)}$,
			avec $$m'(n) = Card\{sommes \quad atteignables \quad filtres\} \leq m(n) \leq 2^n$$.
			\textbf{Attention} cependant, pour $\delta$ trop grand, on perd l'optimalité du résultat.

		\newpage
		\section{Approche de type \textit{Diviser pour régner}}\label{approche_naive}
			\subsection{Question 8 : is\_feasible}\label{is_feasible}
				On nous demande ici de créer une fonction qui sur la donnée d'un entier $s$, d'une liste $l1$ d'entier croissant,
				d'une liste $l2$ d'entier décroissant, renvoie $true$ si $s$ s'écrit comme la somme d'un élément de $l1$ et d'un
				élément de $l2$, et $false$ sinon.
				\newline
				La fonction implémenté suit l'algorithme suivant, qui se sert au maximum du fait que les listes soit triés:
				\begin{algorithm}
					\caption{Renvoie \textbf{true} si $\exists (x, y) \in l1 \times l2 \mid x + y = s$, \textbf{faux} sinon}
					\begin{algorithmic}[1]
						\Function{is\_feasible}{$s \in \mathbb{N}$,
												$l1 \in \mathbb{N}$,
												$l2 \in \mathbb{N}$}
							\For{$y \in l2$ (pris du plus grand au plus petit)}
								\If{$y > s$}
									\State \textbf{Passer au $y$ suivant} (car $y$ est déjà plus grand que 's')
								\EndIf
								\For{$x \in l1$ (pris du plus petit au plus grand)}
									\If{$x + y = s$}
										\State \textbf{Renvoyer true}
									\ElsIf{$x + y > s$}
										\State \textbf{Passer au $y$ suivant} (on a dépassé 's' sans l'atteindre)
									\Else (si $x + y < s$)
										\State \textbf{Passer au $x$ suivant} (car $x + y$ est déjà plus petit que 's')
									\EndIf
								\EndFor
								\State \textbf{Renvoyer faux} ($\forall x \in l1, x + y < s$) on n'atteindra donc pas 's' pour un 'y' plus petit.
							\EndFor
							\State \textbf{Renvoyer faux} (on n'a pas réussi à atteindre 's')
						\EndFunction
					\end{algorithmic}
				\end{algorithm}
			\newpage
			\subsection{Question 9 : best\_feasible}
				Au regard de la Question 8 (\ref{is_feasible}), on nous demande maintenant de créer une fonction qui sur
				la donnée d'un entier $s$, d'une liste $l1$ d'entier croissant, d'une liste $l2$ d'entier décroissant,
				renvoie le plus grand entier $s' \leq s$ somme d'un élément de $l1$ et d'un élément de $l2$
				\newline
				\newline
				N.B: non explicitement dis dans le sujet, mais si un tel entier $s'$ n'existe pas, $-1$ est renvoyé.
				\begin{algorithm}
					\caption{Renvoie \textbf{true} si $\exists (x, y) \in l1 \times l2 \mid x + y = s$, \textbf{faux} sinon}
					\begin{algorithmic}[1]
						\Function{is\_feasible}{$s \in \mathbb{N}$,
												$l1 \in \mathbb{N}$,
												$l2 \in \mathbb{N}$}
							\State $s' \leftarrow -1$
							\For{$y \in l2$ (pris du plus grand au plus petit)}
								\If{$y > s$}
									\State \textbf{Passer au $y$ suivant} (car $y$ est déjà plus grand que 's')
								\EndIf
								\For{$x \in l1$ (pris du plus petit au plus grand)}
									\If{$x + y = s$}
										\State \textbf{Renvoyer $s' \leftarrow x + y$}
									\ElsIf{$x + y > s$}
										\State \textbf{Passer au $y$ suivant} (on a dépassé 's' sans l'atteindre)
									\Else (si $x + y < s$)
										\If{$x + y > s'$}
											\State $s' \leftarrow x + y$
										\EndIf
										\State \textbf{Passer au $x$ suivant} (car $x + y$ est déjà plus petit que 's')
									\EndIf
								\EndFor
								\State \textbf{Renvoyer $s'$} (on a trouvé $s'$ maximum).
							\EndFor
							\State \textbf{Renvoyer $s'$} (on n'a pas réussi à atteindre 's')
						\EndFunction
					\end{algorithmic}
				\end{algorithm}
				
			\newpage
			\subsection{Question 10 : résolution de SUBSET\_SUM\_OPT}

	\newpage
	\section{Références}
		\begin{thebibliography}{}
			\bibitem{cache_friendly}
				'Writting Cache-Friendly code', Gerson Robboy, Portland State University\newline
				\href{http://web.cecs.pdx.edu/~jrb/cs201/lectures/cache.friendly.code.pdf}
				      {\textit{http://web.cecs.pdx.edu/~jrb/cs201/lectures/cache.friendly.code.pdf}}.
  \end{thebibliography}

\end{document}
