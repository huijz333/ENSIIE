# include "dijkstra.h"

/**
 *	@require : le tableau des sommets, le tableau des poids, la file de visite,
 *			et le sommet 's'
 *	@ensure  : initialise les données pour l'algorithme de dijkstra
 *	@assign  : --------------
 */
static void dijkstra_init(t_array * nodes, WEIGHT * costs, t_array * unvisited, INDEX sID) {
	/** on definit toutes les distances de 's' sur '+oo' */
	INDEX n = nodes->size;
	INDEX i;
	for (i = 0 ; i < n ; i++) {
		/* tous les sommets sont à une distance 'infinie' */
		t_nodew * node = (t_nodew *) array_get(nodes, i);
		node->super.pathlen = MAX_NODES;
		node->super.prev = MAX_NODES;
		costs[i] = INF_WEIGHT;
	}
	
	/* on initialise le sommet 'source' */
	t_nodew * s = (t_nodew *) array_get(nodes, sID);
	s->super.pathlen = 0;
	costs[sID] = 0;
	array_add(unvisited, &sID);
}

/**
 *	@require : les poids et la file
 *	@ensure  : renvoie l'index dans la file du prochain sommet à visiter
 *	@assign  : ----------------------------------------------------
 */
static INDEX dijkstra_next_node(WEIGHT * costs, t_array * unvisited) {
	/* on prends le 1er sommet non visité */
	INDEX i = 0;
	INDEX uID = *((INDEX *) array_get(unvisited, i));
	WEIGHT ucost = costs[uID];

	/* pour chaque autre sommets non visités */
	ARRAY_ITERATE_START(unvisited, INDEX *, vIDref, j) {
		INDEX vID = *vIDref;
		WEIGHT vcost = costs[vID];

		/** si ce sommet est de cout plus faible */
		if (vcost < ucost) {
			/** c'est le prochaine que l'on visitera */
			uID = vID;
			ucost = vcost;
			i = j;
		}
	}
	ARRAY_ITERATE_STOP(unvisited, INDEX *, vIDref, j);
	return (i);
}

/**
 *	@require : une matrice representant les arcs et leur poids, deux indices s et t
 *	@ensure  : resout le plus court chemin dans le graphe entre 's' et 't'.
 *			Renvoie 1 si un chemin a été trouvé, 0 sinon.
 *	@assign  : --------------
 */
int dijkstra(t_array * nodes, INDEX s, INDEX t) {
	/** allocation */
	INDEX n = nodes->size;

	/** coût total (poids des arcs) */
	WEIGHT * costs = (WEIGHT *) malloc(n * sizeof(WEIGHT));
	/* tableau enregistrant les sommets non visités */
	t_array * unvisited = array_new(n, sizeof(INDEX));
	/* bitmap enregistrant les sommets visités */
	t_bitmap * visited = bitmap_new(n);
	/** bitmap enregistrant les sommets qui sont déjà dans la file */
	t_bitmap * inQueue = bitmap_new(n);
	if (costs == NULL || unvisited == NULL || visited == NULL || inQueue == NULL) {
		free(costs);
		array_delete(unvisited);
		bitmap_delete(visited);
		bitmap_delete(inQueue);
		return (0);
	}

	/** initialisation */
	dijkstra_init(nodes, costs, unvisited, s);

	/* tant qu'il y a des sommets non-visité */
	while (unvisited->size > 0) {
		/** on cherche un noeud 'u' non visite minimisant le cout */
		INDEX i = dijkstra_next_node(costs, unvisited);
		INDEX uID = *((INDEX *) array_get(unvisited, i));
		array_remove(unvisited, i);
		bitmap_set(visited, uID);

		/* sinon, si on a atteint 't' ou une autre partie connexe, on s'arrete */
		if (uID == t || costs[uID] == INF_WEIGHT) {
			break ;
		}

		/* on minimise les chemins des voisins de 'u' */
		
		/* si 'u' n'a pas de successeurs, on s'arrete */
		t_nodew * u = (t_nodew *) array_get(nodes, uID);
		if (u->super.successors == NULL) {
			continue ;
		}

		/** pour chaque successeurs 'v' de 'u' */
		ARRAY_ITERATE_START(u->super.successors, INDEX *, vIDref, i) {
			/** on recupere le sommet 'v' */
			INDEX vID = *vIDref;
			/** si le sommet voisin a déjà été visité, on passe au suivant */
			if (bitmap_get(visited, vID)) {
				continue ;
			}
			t_nodew * v = (t_nodew *) array_get(nodes, vID);
			/** poids pour aller de 'u' à 'v' par l'arc */
			WEIGHT w = *((WEIGHT *)array_get(u->ws, i));
			/** on recupere le cout precedent */
			WEIGHT ucost = costs[uID];
			WEIGHT newcost = ucost + w;

			if (newcost < costs[vID]) {
				/* on ecrase le chemin precedant par le nouveau chemin */
				costs[vID] = newcost;
				v->super.prev = uID;
				v->super.pathlen = u->super.pathlen + 1;
				/** si le voisin n'est pas dans la file de visite */
				if (!bitmap_get(inQueue, vID)) {
					/* on l'ajoute */
					array_add(unvisited, vIDref);
					bitmap_set(inQueue, vID);
				}
			}
		}
		ARRAY_ITERATE_STOP(u->super.successors, INDEX *, vIDref, i);

	}

	/** libere la mémoire */
	array_delete(unvisited);
	bitmap_delete(visited);
	bitmap_delete(inQueue);
	WEIGHT cost = costs[t];
	free(costs);

	/**
	 *  deux posibilités: si le poids du chemin vaux '+oo',
	 *  c'est que le ne l'a pas atteint via l'algorithme de
	 *  propagation, et donc, il n'est pas dans la meme
	 *  partie connexe que 's'.
	 *  sinon, on a trouvé un chemin.
	 */

	return (cost == INF_WEIGHT ? 0 : 1);
}
